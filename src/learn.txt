psuedo-class >> hover,link,visited
CDN:A content delivery network (CDN) is a group of geographically distributed servers that speed up the delivery of web content by bringing it closer to where users are.
 Ex: cloudfare
hoisting
event loop
event delegation
event bubbling
event capturing
closures
debouncing
throttling
higher order functions

Currying:
Currying is a function that takes one argument at a time and returns a new function expecting the next argument. 
It is a conversion of functions from callable as f(a,b,c)into callable as f(a)(b)(c).

-------------------------------------------------------------------------------------------------------

map vs forech>>> foreach does not return any value whereas map return new array
--compose>> compose take function and evaluate function where one fn out become input of other fn (right to left)
const compose = (...fns)=>val=>fns.reduceRight((prev,fn)=>fn(prev),val)

--pipe >> evaluate from left to right
const pipe = (...fns)=>val=>fns.reduce((prev,fn)=>fn(prev),val)

Promise: The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.

--async/await: makes promise code cleaner

--ecma: ECMAScript is the standard that JavaScript programming language uses. ECMAScript provides the specification on how JavaScript programming language should work.

JavaScript ES6 (also known as ECMAScript 2015 or ECMAScript 6) is the newer version of JavaScript that was introduced in 2015.
----------------------------------------------------------------------------------------
--babel --- It is a transpiler which is used to convert ES6+ code to backward comaptible version of js so that it can be used with current and old browser environment
transform syntax (let a ="xyz")
polyfills to support functionality (like includes)
-----------------------------------------------------------------------------------------
--webpack:  Its a Module bundler which is use to bundle all modules in single file>
 Its main function is to create dependency graph so that it can be injected in proper order
-----------------------------------------------------------------------------------------------
--package.json> dependecies and ^ ,~ version
^ :  backwards-compatible new functionality also old functionality operational,bug fix
Ex: if dependency is 3.4.2 it supports for 3.*.*(means on npm install if 3.5.0 is available then it will update it not 4.0.0)
~ :  bug fix
Ex: if dependency is 3.4.2 it supports for 3.4.*(means on npm install if 3.4.2 is available then it will update it not 3.5.0)
----------------------------------------------------------------------------------------------------------
--defer vs async:
defer: download scripts in background> but executes once dom is loaded(but before DOMContentLoaded event), 
-if there are more than 1 scripts then execution order is maintained
-defer is ignore if script tag does not have src attribute
async: download scripts in background > but executes immediately 
- if there are more than 1 scripts then any script can load first i.e order is not maintained
-async is ignore if script tag does not have src attribute
---------------------------------------------------------------------------
eslint:JavaScript, being a dynamic and loosely-typed language, is especially prone to developer error. ESLint is a linter which helps to improve the code quality and fix bugs beforehand itself to avoid it from coming at runtime. It also helps to avoid hard to debug issues in future

ESLint displays warning or error message when
We use a variable without declaring it
We re-declare the variable
We try to change constant value
We add un-necessary parenthesis
When we use wrong syntax

-----------------------------------------------------------------------------------------------
npm vs npx:
NPM-
>node package manager
>Manages package/ cant run the package directly
>run installed packages via scripts in package.json
>takes space as it install package locally or globally

NPX:
>node package execute
>execute package directly
>can run package without installation remotely / also mentioned in package.json
> save space as it is not installed globally or locally it directly runs it
-------------------------------------------------------------------------------------------
code splitting(lazy load): Usually webpack bundle all files into one and load into app. Bundle increases as files increases so need to split the bundle and load only when files are needed to improve app performance. 
Using dynamic import we can do code splitting . Ex: import { add } from './math';

React.lazy takes a function that must call a dynamic import(). This must return a Promise which resolves to a module with a default export containing a React component.
Ex: const Home = React.lazy(() => import("./components/home"));
We use suspense enclosing lazy component to show some loader or text to UI until the component is loaded
Ex: <Suspense fallback="Loader"><Home></>
----------------------------------------------------------
controlled vs uncontrolled form input:
uncontrolled: traditional html input>> use to get value using ref (ex in case of form submit)
ex: <input type="text" ref = {this.input}/>
controlled :  input field where value is provided by prop and its update on every onchange. so Ui and data are in sync
ex: <input type="text" value={this.state.name} onchange={this.changeName}/>

-------------------------------------------------------------------------------------------
>>The lifecycle of an HTML page has three important events:
--DOMContentLoaded –(it waits for scripts before them to load except async ) the browser fully loaded HTML, and the DOM tree is built, but external resources like pictures <img> and stylesheets may not yet have loaded.
--load – not only HTML is loaded, but also all the external resources: images, styles etc.
--unload – the user leaves the page
--onbeforeunload - If a visitor initiated navigation away from the page or tries to close the window, the beforeunload handler asks for additional confirmation.
If we cancel the event, the browser may ask the visitor if they are sure.
--------------------------------------------------------------------------------------------------
>>There are cases when we are not sure whether the document is ready or not. We’d like our function to execute when the DOM is loaded, be it now or later.

The document.readyState property tells us about the current loading state.

There are 3 possible values:

"loading" – the document is loading.
"interactive" – the document was fully read.
"complete" – the document was fully read and all resources (like images) are loaded too.

-onload >> check if element with src attribute is loaded
-onerror >> check if element with src attribute is has some error on loading 

---------------------------------------------------------------------
>>What is Browserslist?
Browserslist is a tool that allows specifying which browsers should be supported in your frontend app by specifying "queries" in a config file. 
usage: By using browserslist, transpilers/bundlers know what browsers you want to support, so they can "group" browsers in different categories and generate separate bundles,
ex: 0.2%: All browsers that have at least 0,2% of global market share
not dead: Exclude browsers without official support in the last 24 months
not ie <= 11: Exclude IE 11 and older versions
not op_mini all: Exclude Opera Mini

--------------------------------------------------------------------------------------
>> REDUX
ACTIONS:
-- They are plan JS objects
-- They are synchronous
-- Actions tells store that there is a change (Pass packet of information to store)

Ex: {type:"ADD_CHANGE",payload:data}

REDUCER:
-- Reducer are pure JavaScript functions
-- Reducer takes current state and action as input and return new state and then store updates the new state
-- Reducers are responsible for particular state in the store
-- All reducers are called when an action is dispatched

STORE:
Provider take store as props and its main function is to provide store to all components

REDUX-THUNK:
Thunk are functions which are used to delay a functionality
-- to make action asynchronous we wrap it by thunk function
Ex: Before thunk action creator looks like:

fetchApi(){
    return {type:"ADD_CHANGE",payload:data}
}

After thunk:
fetchApi(){

    return(dispatch)=>{

    dispatch({type:"ADD_CHANGE",payload:data})
    }

}

-- When an action is dispatched it goes to thunk, thunk sees what action creator has returned , if an object is returned it passes it to store directly, if a function is returned then passes dispatch as a parameter and calls that function
-------------------------------------------------------------------------------
ALGORITHM:
MERGE SORT: Divide n conquer ALGORITHM
- find mid
- divide input into two parts first 0 to mid(left) and second mid+1 to length(right)
- sort both and merge again
- repeat process 
> mergeSort(left)
> mergeSort(right)
> merge (left,right,orginalArr)>> check at i index for left and j index for right which is smaller and fill at k index of orginal

--rest vs spread operator:
SPREAD: Takes iterable and spread it (ex: var abc = [1,2,3]>>[...abc]>[1,2,3])
REST: function call if we do not know no. of arguments(ex: func(...args))

-------------------------------------------------------------------------
--shallow vs deep copy
SHALLOW COPY: 
-- for array> spread operator, Array.from,slice do shallow copy, for object> Object.assign, spread operator 
Same memory is allocated to copied>> It copies non primitive containing primitives values
ex:
let person = {
    "name":"vipul",
    "address":{
        "city":"gkp",
    }
}

let copied = Object.assign({},person);
copied.name = "test";
copied.address.city="noida"
>> now in person object, name is not changed but address will be changed

DEEP COPY:
-- Json.parse,JSON.stringfy do deep copy
Different memory is allocated to copied>> It copies non primitive containing non primitive/primitives values
ex:
let person = {
    "name":"vipul",
    "address":{
        "city":"gkp",
    }
}

let copied = JSON.parse(JSON.stringfy(person));
copied.name = "test";
copied.address.city="noida"
>> now in person object, nothing will be changed
-----------------------------------------------------------------

--pure component
It implements componentshouldUpdate with shallow props and state.
If prev state and props are not changed then component will not re-render

---------------------------------------------------------------------------------------------------------

-- document.getelementbyid vs ref>> Anyone can be used
----------------------------------------------------------------------------------------------------------
-- component lifecycle>(in order which they are called)
MOUNTING: When new instance created or inserted in DOM
constructor
static getDerivedStateFromProps>>if initial state depends on props, cannot use this inside it, return null or object updating state, called on every rerender
render 
componentDidMount

UPDATING: When state and props are updated
static getDerivedStateFromProps,
shouldComponentUpdate(nextState,nextProps)>> tells if component should rerender or not,
render
getSnapshotsbeforeupdate
componentDidUpdate

UNMOUNTING: when component is removed from DOM
> componentwillunmount

ERROR: when there is error in component
> static getDerivedStateFromError> show fallback UI in case of error>> return state
 componentDidCatch>> logs error information
-------------------------------------------------------
React fragment: It let us group children elements without adding any extra node in DOM >> Ex: <><h1></h1></>

--------------------------------------------------
ErrorBoundry> 
-- handle error in constructor,render,lifecycle
   Handle error in production build not on local
   Do not handle error in event handler
   static getDerivedStateFromError or componentDidCatch is used to get error state

-------------------------------------------------------------------------------------

useCallback-> It is a hook which return memoized version of function that changes if one of the dependency chnages (It caches whole function)
useMemo - It caches the result from the function >> if dependency does not changes it will not change

-----------------------------------------------------------------------------------------------------------
Cookies- 
>stores info max 4KB
>can be deleted by setting expiry date(document.cookie="name=vipul;expires="+new Date().toString())[accept only UTC date]// max-age can be used which uses time in seconds
>can be send to server on every http request
>use Secure for sending cookes over https(document.cookie="name=vipul;Secure")
>use HttpOnly when you do not want client to update the cookie (document.cookie="name=vipul;HttpOnly")
>path="/" make cookie accessible to provided path only
-----------------------------------------------------------------------------------------------
Prototypal inheritance
>In JavaScript, objects have a special hidden property [[Prototype]] 
that is either null or references another object. That object is called “a prototype”.
>When we read a property from object, and it’s missing, JavaScript automatically takes it from the prototype.
>there can be only one _proto
> we can read proto but cannot update 

---------------------------------------------------------------
Enumerable: 
>An enumerable property in JavaScript means that a property can be viewed if it is iterated using the for…in loop or Object.keys() method. 
All the properties which are created by simple assignment or property initializer are enumerable by default.
Ex:
const student = {
    registration: '12342',
    name: 'Sandeep',
    age: 27,
};
  
// This sets the enumerable attribute
// of marks property to false 
  
Object.defineProperty(student, 'marks', {
    value: 98,
    configurable: true,
    writable: false,
    enumerable: false,
});

console.log(student.propertyIsEnumerable('marks')); returns false;

for (const key in student){
    console.log(key)
} // registration name age>>>>>>>. marks will not be displayed as enumerable is set to false

----------------------------------------------------------------

A polyfill is a browser fallback, made in JavaScript, 
that allows functionality you expect to work in modern browsers to work in older browsers
----------------------------------------------------------------------------------------

-- different type of dependecies package.json
dependencies: All of the dependencies your project uses (the external code that the project relies on) are listed here
devDependencies : Packages which are only needed during development, and aren't needed in production.
peer dependecies: peerDependencies are for plugins, libraries that require a "host" library to perform their function, but may have been written at a time before the latest version of the host was released.
---------------------------------------------------------------------------------------------------

THIS:
value of this always depends on how it is called;

ex:

let obj = {
    functionA(){
        console.log(this);
    }

     functionB(){
        functionC(){
            console.log(this)
        }
        return functionC();
    }
}

>> obj.functionA()------- will give ans as obj object as it is called by obj itself;
let test = obj.functionA;
>> test(); --------- will global object as it is called directly
>> obj.functionB(); --------- will global object as it is called directly (line 318)

If we create object using new keyword then it always points to that object;
ex:
function funcA(){
    return this;
}

var myfun = new funcA();
console.log(myfun) // returns function funcA(){}
------------------------------------------------------------------------------------------
-- arrow vs normal function

>Arrow function are not hoisted;
>this is binded by previously value of this:
ex:
const obj = {
    someMethod: () => {
        return this;
    }
}

let test = obj.someMethod;
console.log(test()) // points to global (as this means window object)
console.log(obj) // points to global(as this means window object)

------------------------------------------------------------------------------------------
-- es6 features

1) Let & Const
2) Arrow function
3) Template liteteral
4) Default parameter
5) Object literal
6) Rest & spread operators
7) Destructing Assignment
+) Class, Module, Promises, Iterators e.t.c

----------------------------------------------------------------------------------------------

-- div vs span

>> div is a block element and always starts in a new line
>> span is a inline element and always appears in same line

---------------------------------------------------------------------------------------------

INLINE VS BLOCK vs INLINE-BLOCK:
-- Inline cannot have margin padding height and will always be in same line 
ex: a, span, img

--Block can have margin padding top and will always be in next line
ex: div, p, h1, section

-- Inline BLOCK can have margin padding height and will always be in same line 

------------------------------------------------------------------------------------------------

-- thunk vs saga

thunk:                              
1.Less boilerplate code.                                                        
2.Easy to understand as compared to redux-saga    
3.Action creators may hold too much async logic          
4.uses callbacks which may lead to situations like‘callback hell’ in some cases.

Saga:
1.More boilerplate code
2.Difficult to understand as there are multiple concepts to learn like generator  
3.Action creators stay pure
4.Saga works like a separate thread or a background process that is solely 
responsible for making your side effects or API calls unlike redux-thunk
------------------------------------------------------------------------------------------
-- dom vs virtual dom vs shadow dom
DOM:
-DOM is an API for HTML or XML documents and it creates a logical structure which can be accessed and manipulated.
-It is object-based representation of the HTML elements. 
-The browser converts the code into a tree-like structure that is made into javascript and compiled by the HTML and CSS compilers.

Virtual DOM:

-Virtual DOM, in simple terms, is nothing but the complete and full representation of an actual DOM.
-Since any changes to the DOM causes the page to re-render more often than not, Virtual DOM primarily attempts to avoid any unnecessary and expensive changes to the DOM.
-This is achieved by grouping changes and doing a single re-render instead of several small ones.
-A copy of the DOM is saved in the memory and is used to compare any changes being done anywhere in the DOM, it’s compared to find differences. Thus, only those parts of the application are re-rendered which are updated instead of re-rendering the entire DOM.
-VueJS and ReactJS both use Virtual DOM.

Shadow DOM:

-Shadow DOM, on the other hand, relates mostly to the concept of encapsulation. It is a tool that allows developers to overcome DOM encapsulation.
-It refers to the browser’s potential to add a subtree of DOM elements into the rendering of a document, but not into the DOM tree of the main document.
-Thus, it isolates the DOM and ensures that the DOM of a component is a separate element that won’t appear in a global DOM.
ex: this.attachShadow({mode: 'open'}); -- open means you can manipulate shadow dom

-- css position:

STATIC (default): normal flow>> cannot change top bottom left right;
RELATIVE: remove from normal document flow >> almost same as static but can change top bottom left right , 
change top bottom left right respect to original position
ABSOLUTE :  remove from normal document flow >> by default if we give top bottom left right it will be as per body, 
if parent position is set to relative then absolute then top bottom left right it will be as per the parent
FIXED: remove from normal document flow >>by default if we give top bottom left right it will be as per body
if we scroll then also its postion is fixed
STICKY: almost same as relative but if we scroll it and as per top bottom left right it becomes fixed

---------------------------------------------------------------------------------------------------------
pixel: fixed width as given
% : relative to parent 
vh/vw: relative to screen present
rem : relative to root font size
em: relative to parent font size
------------------------------------------------------------------------------
-- boxsizing: (default: content-box)
>>Include padding and border in the element's total width and height
------------------------------------------------------------------------------

-- getBoundingClientRect
-- CSR VS SSR
-- optimization ques
-- micro frontend architecture
-- renderToString
-- reactdom.hydrate
-- progressive hydration
-- Oauth 2.0

---------------------------------------------------------------------------------------------------------------------
-- webAPI 
 APIs that are built into the browser and provide native features that can also be used in a web app.

---------------------------------------------------------------------------------------------------------------------
-- doctype:
The <!DOCTYPE html> (syntax for HTML5) declaration is used to inform a website visitor's browser that the document being rendered is an HTML document

--------------------------------------------------------------------------------------------------------------------
Semantic tags:
Semantic HTML or semantic markup is HTML that introduces meaning to the web page rather than just presentation.
Ex: <p><body>

--security attacks on frontend:
> Clickjacking: 
Clickjacking, also known as a “UI redress attack”, is when an attacker uses multiple transparent or opaque layers to 
trick a user into clicking on a button or link on another page when they were intending to click on the top level page. 
Prevention:
>>X-Frame-Options HTTP header with value same origin
>>"Content-Security-Policy", "frame-ancestors 'self';"

>Cross Site Scripting (XSS):
XSS attacks occur when an attacker uses a web application to send malicious code, generally in the form of a browser side script, to a different end user
Prevention:
To prevent this attack in pure JS, let’s write a custom function that looks out for special characters such as “<” , “>” and “&” 
String.prototype.escape = function() {
    var tagsToReplace = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;'
    };
    return this.replace(/[&<>]/g, function(tag) {
        return tagsToReplace[tag] || tag;
    });
};

>Cross Site Request Forgery (CSRF):
Cross-Site Request Forgery (CSRF) is an attack that forces an end user to execute unwanted actions on a web application in which they’re currently authenticated. 
With a little help of social engineering (such as sending a link via email or chat), an attacker may trick the users of a web application into executing actions of the attacker’s choosing.
Prevention:
Random Tokens
Same site in cookies
